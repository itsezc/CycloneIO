// Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  badge: (where?: BadgeWhereInput) => Promise<boolean>;
  ban: (where?: BanWhereInput) => Promise<boolean>;
  bot: (where?: BotWhereInput) => Promise<boolean>;
  catalogFeatured: (where?: CatalogFeaturedWhereInput) => Promise<boolean>;
  catalogItems: (where?: CatalogItemsWhereInput) => Promise<boolean>;
  catalogPage: (where?: CatalogPageWhereInput) => Promise<boolean>;
  chatlog: (where?: ChatlogWhereInput) => Promise<boolean>;
  chatlogConsole: (where?: ChatlogConsoleWhereInput) => Promise<boolean>;
  chatlogConsoleInvitations: (
    where?: ChatlogConsoleInvitationsWhereInput
  ) => Promise<boolean>;
  currencies: (where?: CurrenciesWhereInput) => Promise<boolean>;
  habbo: (where?: HabboWhereInput) => Promise<boolean>;
  habboBadges: (where?: HabboBadgesWhereInput) => Promise<boolean>;
  habboItems: (where?: HabboItemsWhereInput) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  navigatorCategory: (where?: NavigatorCategoryWhereInput) => Promise<boolean>;
  navigatorTab: (where?: NavigatorTabWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  rank: (where?: RankWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  badge: (where: BadgeWhereUniqueInput) => BadgeNullablePromise;
  badges: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Badge>;
  badgesConnection: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BadgeConnectionPromise;
  ban: (where: BanWhereUniqueInput) => BanNullablePromise;
  bans: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ban>;
  bansConnection: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BanConnectionPromise;
  bot: (where: BotWhereUniqueInput) => BotNullablePromise;
  bots: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bot>;
  botsConnection: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotConnectionPromise;
  catalogFeatured: (
    where: CatalogFeaturedWhereUniqueInput
  ) => CatalogFeaturedNullablePromise;
  catalogFeatureds: (args?: {
    where?: CatalogFeaturedWhereInput;
    orderBy?: CatalogFeaturedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogFeatured>;
  catalogFeaturedsConnection: (args?: {
    where?: CatalogFeaturedWhereInput;
    orderBy?: CatalogFeaturedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogFeaturedConnectionPromise;
  catalogItems: (
    where: CatalogItemsWhereUniqueInput
  ) => CatalogItemsNullablePromise;
  catalogItemses: (args?: {
    where?: CatalogItemsWhereInput;
    orderBy?: CatalogItemsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogItems>;
  catalogItemsesConnection: (args?: {
    where?: CatalogItemsWhereInput;
    orderBy?: CatalogItemsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogItemsConnectionPromise;
  catalogPage: (
    where: CatalogPageWhereUniqueInput
  ) => CatalogPageNullablePromise;
  catalogPages: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogPage>;
  catalogPagesConnection: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogPageConnectionPromise;
  chatlog: (where: ChatlogWhereUniqueInput) => ChatlogNullablePromise;
  chatlogs: (args?: {
    where?: ChatlogWhereInput;
    orderBy?: ChatlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Chatlog>;
  chatlogsConnection: (args?: {
    where?: ChatlogWhereInput;
    orderBy?: ChatlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConnectionPromise;
  chatlogConsole: (
    where: ChatlogConsoleWhereUniqueInput
  ) => ChatlogConsoleNullablePromise;
  chatlogConsoles: (args?: {
    where?: ChatlogConsoleWhereInput;
    orderBy?: ChatlogConsoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatlogConsole>;
  chatlogConsolesConnection: (args?: {
    where?: ChatlogConsoleWhereInput;
    orderBy?: ChatlogConsoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConsoleConnectionPromise;
  chatlogConsoleInvitations: (
    where: ChatlogConsoleInvitationsWhereUniqueInput
  ) => ChatlogConsoleInvitationsNullablePromise;
  chatlogConsoleInvitationses: (args?: {
    where?: ChatlogConsoleInvitationsWhereInput;
    orderBy?: ChatlogConsoleInvitationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatlogConsoleInvitations>;
  chatlogConsoleInvitationsesConnection: (args?: {
    where?: ChatlogConsoleInvitationsWhereInput;
    orderBy?: ChatlogConsoleInvitationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConsoleInvitationsConnectionPromise;
  currencies: (where: CurrenciesWhereUniqueInput) => CurrenciesNullablePromise;
  currencieses: (args?: {
    where?: CurrenciesWhereInput;
    orderBy?: CurrenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currencies>;
  currenciesesConnection: (args?: {
    where?: CurrenciesWhereInput;
    orderBy?: CurrenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrenciesConnectionPromise;
  habbo: (where: HabboWhereUniqueInput) => HabboNullablePromise;
  habboes: (args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Habbo>;
  habboesConnection: (args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HabboConnectionPromise;
  habboBadges: (
    where: HabboBadgesWhereUniqueInput
  ) => HabboBadgesNullablePromise;
  habboBadgeses: (args?: {
    where?: HabboBadgesWhereInput;
    orderBy?: HabboBadgesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HabboBadges>;
  habboBadgesesConnection: (args?: {
    where?: HabboBadgesWhereInput;
    orderBy?: HabboBadgesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HabboBadgesConnectionPromise;
  habboItems: (where: HabboItemsWhereUniqueInput) => HabboItemsNullablePromise;
  habboItemses: (args?: {
    where?: HabboItemsWhereInput;
    orderBy?: HabboItemsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HabboItems>;
  habboItemsesConnection: (args?: {
    where?: HabboItemsWhereInput;
    orderBy?: HabboItemsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HabboItemsConnectionPromise;
  language: (where: LanguageWhereUniqueInput) => LanguageNullablePromise;
  languages: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Language>;
  languagesConnection: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageConnectionPromise;
  navigatorCategory: (
    where: NavigatorCategoryWhereUniqueInput
  ) => NavigatorCategoryNullablePromise;
  navigatorCategories: (args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NavigatorCategory>;
  navigatorCategoriesConnection: (args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NavigatorCategoryConnectionPromise;
  navigatorTab: (
    where: NavigatorTabWhereUniqueInput
  ) => NavigatorTabNullablePromise;
  navigatorTabs: (args?: {
    where?: NavigatorTabWhereInput;
    orderBy?: NavigatorTabOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NavigatorTab>;
  navigatorTabsConnection: (args?: {
    where?: NavigatorTabWhereInput;
    orderBy?: NavigatorTabOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NavigatorTabConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  rank: (where: RankWhereUniqueInput) => RankNullablePromise;
  ranks: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Rank>;
  ranksConnection: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RankConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBadge: (data: BadgeCreateInput) => BadgePromise;
  updateBadge: (args: {
    data: BadgeUpdateInput;
    where: BadgeWhereUniqueInput;
  }) => BadgePromise;
  updateManyBadges: (args: {
    data: BadgeUpdateManyMutationInput;
    where?: BadgeWhereInput;
  }) => BatchPayloadPromise;
  upsertBadge: (args: {
    where: BadgeWhereUniqueInput;
    create: BadgeCreateInput;
    update: BadgeUpdateInput;
  }) => BadgePromise;
  deleteBadge: (where: BadgeWhereUniqueInput) => BadgePromise;
  deleteManyBadges: (where?: BadgeWhereInput) => BatchPayloadPromise;
  createBan: (data: BanCreateInput) => BanPromise;
  updateBan: (args: {
    data: BanUpdateInput;
    where: BanWhereUniqueInput;
  }) => BanPromise;
  updateManyBans: (args: {
    data: BanUpdateManyMutationInput;
    where?: BanWhereInput;
  }) => BatchPayloadPromise;
  upsertBan: (args: {
    where: BanWhereUniqueInput;
    create: BanCreateInput;
    update: BanUpdateInput;
  }) => BanPromise;
  deleteBan: (where: BanWhereUniqueInput) => BanPromise;
  deleteManyBans: (where?: BanWhereInput) => BatchPayloadPromise;
  createBot: (data: BotCreateInput) => BotPromise;
  updateBot: (args: {
    data: BotUpdateInput;
    where: BotWhereUniqueInput;
  }) => BotPromise;
  updateManyBots: (args: {
    data: BotUpdateManyMutationInput;
    where?: BotWhereInput;
  }) => BatchPayloadPromise;
  upsertBot: (args: {
    where: BotWhereUniqueInput;
    create: BotCreateInput;
    update: BotUpdateInput;
  }) => BotPromise;
  deleteBot: (where: BotWhereUniqueInput) => BotPromise;
  deleteManyBots: (where?: BotWhereInput) => BatchPayloadPromise;
  createCatalogFeatured: (
    data: CatalogFeaturedCreateInput
  ) => CatalogFeaturedPromise;
  updateCatalogFeatured: (args: {
    data: CatalogFeaturedUpdateInput;
    where: CatalogFeaturedWhereUniqueInput;
  }) => CatalogFeaturedPromise;
  updateManyCatalogFeatureds: (args: {
    data: CatalogFeaturedUpdateManyMutationInput;
    where?: CatalogFeaturedWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogFeatured: (args: {
    where: CatalogFeaturedWhereUniqueInput;
    create: CatalogFeaturedCreateInput;
    update: CatalogFeaturedUpdateInput;
  }) => CatalogFeaturedPromise;
  deleteCatalogFeatured: (
    where: CatalogFeaturedWhereUniqueInput
  ) => CatalogFeaturedPromise;
  deleteManyCatalogFeatureds: (
    where?: CatalogFeaturedWhereInput
  ) => BatchPayloadPromise;
  createCatalogItems: (data: CatalogItemsCreateInput) => CatalogItemsPromise;
  updateCatalogItems: (args: {
    data: CatalogItemsUpdateInput;
    where: CatalogItemsWhereUniqueInput;
  }) => CatalogItemsPromise;
  updateManyCatalogItemses: (args: {
    data: CatalogItemsUpdateManyMutationInput;
    where?: CatalogItemsWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogItems: (args: {
    where: CatalogItemsWhereUniqueInput;
    create: CatalogItemsCreateInput;
    update: CatalogItemsUpdateInput;
  }) => CatalogItemsPromise;
  deleteCatalogItems: (
    where: CatalogItemsWhereUniqueInput
  ) => CatalogItemsPromise;
  deleteManyCatalogItemses: (
    where?: CatalogItemsWhereInput
  ) => BatchPayloadPromise;
  createCatalogPage: (data: CatalogPageCreateInput) => CatalogPagePromise;
  updateCatalogPage: (args: {
    data: CatalogPageUpdateInput;
    where: CatalogPageWhereUniqueInput;
  }) => CatalogPagePromise;
  updateManyCatalogPages: (args: {
    data: CatalogPageUpdateManyMutationInput;
    where?: CatalogPageWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogPage: (args: {
    where: CatalogPageWhereUniqueInput;
    create: CatalogPageCreateInput;
    update: CatalogPageUpdateInput;
  }) => CatalogPagePromise;
  deleteCatalogPage: (where: CatalogPageWhereUniqueInput) => CatalogPagePromise;
  deleteManyCatalogPages: (
    where?: CatalogPageWhereInput
  ) => BatchPayloadPromise;
  createChatlog: (data: ChatlogCreateInput) => ChatlogPromise;
  updateChatlog: (args: {
    data: ChatlogUpdateInput;
    where: ChatlogWhereUniqueInput;
  }) => ChatlogPromise;
  updateManyChatlogs: (args: {
    data: ChatlogUpdateManyMutationInput;
    where?: ChatlogWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlog: (args: {
    where: ChatlogWhereUniqueInput;
    create: ChatlogCreateInput;
    update: ChatlogUpdateInput;
  }) => ChatlogPromise;
  deleteChatlog: (where: ChatlogWhereUniqueInput) => ChatlogPromise;
  deleteManyChatlogs: (where?: ChatlogWhereInput) => BatchPayloadPromise;
  createChatlogConsole: (
    data: ChatlogConsoleCreateInput
  ) => ChatlogConsolePromise;
  updateChatlogConsole: (args: {
    data: ChatlogConsoleUpdateInput;
    where: ChatlogConsoleWhereUniqueInput;
  }) => ChatlogConsolePromise;
  updateManyChatlogConsoles: (args: {
    data: ChatlogConsoleUpdateManyMutationInput;
    where?: ChatlogConsoleWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlogConsole: (args: {
    where: ChatlogConsoleWhereUniqueInput;
    create: ChatlogConsoleCreateInput;
    update: ChatlogConsoleUpdateInput;
  }) => ChatlogConsolePromise;
  deleteChatlogConsole: (
    where: ChatlogConsoleWhereUniqueInput
  ) => ChatlogConsolePromise;
  deleteManyChatlogConsoles: (
    where?: ChatlogConsoleWhereInput
  ) => BatchPayloadPromise;
  createChatlogConsoleInvitations: (
    data: ChatlogConsoleInvitationsCreateInput
  ) => ChatlogConsoleInvitationsPromise;
  updateChatlogConsoleInvitations: (args: {
    data: ChatlogConsoleInvitationsUpdateInput;
    where: ChatlogConsoleInvitationsWhereUniqueInput;
  }) => ChatlogConsoleInvitationsPromise;
  updateManyChatlogConsoleInvitationses: (args: {
    data: ChatlogConsoleInvitationsUpdateManyMutationInput;
    where?: ChatlogConsoleInvitationsWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlogConsoleInvitations: (args: {
    where: ChatlogConsoleInvitationsWhereUniqueInput;
    create: ChatlogConsoleInvitationsCreateInput;
    update: ChatlogConsoleInvitationsUpdateInput;
  }) => ChatlogConsoleInvitationsPromise;
  deleteChatlogConsoleInvitations: (
    where: ChatlogConsoleInvitationsWhereUniqueInput
  ) => ChatlogConsoleInvitationsPromise;
  deleteManyChatlogConsoleInvitationses: (
    where?: ChatlogConsoleInvitationsWhereInput
  ) => BatchPayloadPromise;
  createCurrencies: (data: CurrenciesCreateInput) => CurrenciesPromise;
  updateCurrencies: (args: {
    data: CurrenciesUpdateInput;
    where: CurrenciesWhereUniqueInput;
  }) => CurrenciesPromise;
  updateManyCurrencieses: (args: {
    data: CurrenciesUpdateManyMutationInput;
    where?: CurrenciesWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrencies: (args: {
    where: CurrenciesWhereUniqueInput;
    create: CurrenciesCreateInput;
    update: CurrenciesUpdateInput;
  }) => CurrenciesPromise;
  deleteCurrencies: (where: CurrenciesWhereUniqueInput) => CurrenciesPromise;
  deleteManyCurrencieses: (where?: CurrenciesWhereInput) => BatchPayloadPromise;
  createHabbo: (data: HabboCreateInput) => HabboPromise;
  updateHabbo: (args: {
    data: HabboUpdateInput;
    where: HabboWhereUniqueInput;
  }) => HabboPromise;
  updateManyHabboes: (args: {
    data: HabboUpdateManyMutationInput;
    where?: HabboWhereInput;
  }) => BatchPayloadPromise;
  upsertHabbo: (args: {
    where: HabboWhereUniqueInput;
    create: HabboCreateInput;
    update: HabboUpdateInput;
  }) => HabboPromise;
  deleteHabbo: (where: HabboWhereUniqueInput) => HabboPromise;
  deleteManyHabboes: (where?: HabboWhereInput) => BatchPayloadPromise;
  createHabboBadges: (data: HabboBadgesCreateInput) => HabboBadgesPromise;
  updateHabboBadges: (args: {
    data: HabboBadgesUpdateInput;
    where: HabboBadgesWhereUniqueInput;
  }) => HabboBadgesPromise;
  updateManyHabboBadgeses: (args: {
    data: HabboBadgesUpdateManyMutationInput;
    where?: HabboBadgesWhereInput;
  }) => BatchPayloadPromise;
  upsertHabboBadges: (args: {
    where: HabboBadgesWhereUniqueInput;
    create: HabboBadgesCreateInput;
    update: HabboBadgesUpdateInput;
  }) => HabboBadgesPromise;
  deleteHabboBadges: (where: HabboBadgesWhereUniqueInput) => HabboBadgesPromise;
  deleteManyHabboBadgeses: (
    where?: HabboBadgesWhereInput
  ) => BatchPayloadPromise;
  createHabboItems: (data: HabboItemsCreateInput) => HabboItemsPromise;
  updateHabboItems: (args: {
    data: HabboItemsUpdateInput;
    where: HabboItemsWhereUniqueInput;
  }) => HabboItemsPromise;
  updateManyHabboItemses: (args: {
    data: HabboItemsUpdateManyMutationInput;
    where?: HabboItemsWhereInput;
  }) => BatchPayloadPromise;
  upsertHabboItems: (args: {
    where: HabboItemsWhereUniqueInput;
    create: HabboItemsCreateInput;
    update: HabboItemsUpdateInput;
  }) => HabboItemsPromise;
  deleteHabboItems: (where: HabboItemsWhereUniqueInput) => HabboItemsPromise;
  deleteManyHabboItemses: (where?: HabboItemsWhereInput) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (args: {
    data: LanguageUpdateInput;
    where: LanguageWhereUniqueInput;
  }) => LanguagePromise;
  updateManyLanguages: (args: {
    data: LanguageUpdateManyMutationInput;
    where?: LanguageWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguage: (args: {
    where: LanguageWhereUniqueInput;
    create: LanguageCreateInput;
    update: LanguageUpdateInput;
  }) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createNavigatorCategory: (
    data: NavigatorCategoryCreateInput
  ) => NavigatorCategoryPromise;
  updateNavigatorCategory: (args: {
    data: NavigatorCategoryUpdateInput;
    where: NavigatorCategoryWhereUniqueInput;
  }) => NavigatorCategoryPromise;
  updateManyNavigatorCategories: (args: {
    data: NavigatorCategoryUpdateManyMutationInput;
    where?: NavigatorCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertNavigatorCategory: (args: {
    where: NavigatorCategoryWhereUniqueInput;
    create: NavigatorCategoryCreateInput;
    update: NavigatorCategoryUpdateInput;
  }) => NavigatorCategoryPromise;
  deleteNavigatorCategory: (
    where: NavigatorCategoryWhereUniqueInput
  ) => NavigatorCategoryPromise;
  deleteManyNavigatorCategories: (
    where?: NavigatorCategoryWhereInput
  ) => BatchPayloadPromise;
  createNavigatorTab: (data: NavigatorTabCreateInput) => NavigatorTabPromise;
  updateNavigatorTab: (args: {
    data: NavigatorTabUpdateInput;
    where: NavigatorTabWhereUniqueInput;
  }) => NavigatorTabPromise;
  updateManyNavigatorTabs: (args: {
    data: NavigatorTabUpdateManyMutationInput;
    where?: NavigatorTabWhereInput;
  }) => BatchPayloadPromise;
  upsertNavigatorTab: (args: {
    where: NavigatorTabWhereUniqueInput;
    create: NavigatorTabCreateInput;
    update: NavigatorTabUpdateInput;
  }) => NavigatorTabPromise;
  deleteNavigatorTab: (
    where: NavigatorTabWhereUniqueInput
  ) => NavigatorTabPromise;
  deleteManyNavigatorTabs: (
    where?: NavigatorTabWhereInput
  ) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  updateManyNewses: (args: {
    data: NewsUpdateManyMutationInput;
    where?: NewsWhereInput;
  }) => BatchPayloadPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createRank: (data: RankCreateInput) => RankPromise;
  updateRank: (args: {
    data: RankUpdateInput;
    where: RankWhereUniqueInput;
  }) => RankPromise;
  updateManyRanks: (args: {
    data: RankUpdateManyMutationInput;
    where?: RankWhereInput;
  }) => BatchPayloadPromise;
  upsertRank: (args: {
    where: RankWhereUniqueInput;
    create: RankCreateInput;
    update: RankUpdateInput;
  }) => RankPromise;
  deleteRank: (where: RankWhereUniqueInput) => RankPromise;
  deleteManyRanks: (where?: RankWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  badge: (
    where?: BadgeSubscriptionWhereInput
  ) => BadgeSubscriptionPayloadSubscription;
  ban: (
    where?: BanSubscriptionWhereInput
  ) => BanSubscriptionPayloadSubscription;
  bot: (
    where?: BotSubscriptionWhereInput
  ) => BotSubscriptionPayloadSubscription;
  catalogFeatured: (
    where?: CatalogFeaturedSubscriptionWhereInput
  ) => CatalogFeaturedSubscriptionPayloadSubscription;
  catalogItems: (
    where?: CatalogItemsSubscriptionWhereInput
  ) => CatalogItemsSubscriptionPayloadSubscription;
  catalogPage: (
    where?: CatalogPageSubscriptionWhereInput
  ) => CatalogPageSubscriptionPayloadSubscription;
  chatlog: (
    where?: ChatlogSubscriptionWhereInput
  ) => ChatlogSubscriptionPayloadSubscription;
  chatlogConsole: (
    where?: ChatlogConsoleSubscriptionWhereInput
  ) => ChatlogConsoleSubscriptionPayloadSubscription;
  chatlogConsoleInvitations: (
    where?: ChatlogConsoleInvitationsSubscriptionWhereInput
  ) => ChatlogConsoleInvitationsSubscriptionPayloadSubscription;
  currencies: (
    where?: CurrenciesSubscriptionWhereInput
  ) => CurrenciesSubscriptionPayloadSubscription;
  habbo: (
    where?: HabboSubscriptionWhereInput
  ) => HabboSubscriptionPayloadSubscription;
  habboBadges: (
    where?: HabboBadgesSubscriptionWhereInput
  ) => HabboBadgesSubscriptionPayloadSubscription;
  habboItems: (
    where?: HabboItemsSubscriptionWhereInput
  ) => HabboItemsSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  navigatorCategory: (
    where?: NavigatorCategorySubscriptionWhereInput
  ) => NavigatorCategorySubscriptionPayloadSubscription;
  navigatorTab: (
    where?: NavigatorTabSubscriptionWhereInput
  ) => NavigatorTabSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  rank: (
    where?: RankSubscriptionWhereInput
  ) => RankSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BadgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC";

export type banStatus = "BANNED" | "APPEALING" | "REJECTED";

export type banType = "USER" | "IP" | "MACHINE";

export type BanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "user_ASC"
  | "user_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "machine_ASC"
  | "machine_DESC"
  | "by_ASC"
  | "by_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "inventory_ASC"
  | "inventory_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "type_ASC"
  | "type_DESC"
  | "messages_ASC"
  | "messages_DESC"
  | "chatBubble_ASC"
  | "chatBubble_DESC"
  | "chatAuto_ASC"
  | "chatAuto_DESC"
  | "chatRandom_ASC"
  | "chatRandom_DESC"
  | "chatDelay_ASC"
  | "chatDelay_DESC";

export type CatalogPageLayout =
  | "DEFAULT"
  | "FRONTPAGE"
  | "CLUB_BUY"
  | "CLUB_GIFT"
  | "RECYCLER"
  | "RECYCLER_INFO"
  | "RECYCLER_PRIZES"
  | "TROPHIES"
  | "PLASTO"
  | "MARKETPLACE"
  | "MARKETPLACE_OWN_ITEMS"
  | "PETS"
  | "SPACES"
  | "SOUNDMACHINE"
  | "GUILDS"
  | "INFO_DUCKETS"
  | "INFO_RENTABLES"
  | "INFO_PETS"
  | "ROOMADS"
  | "SINGLE_BUNDLE"
  | "SOLD_LTD_ITEMS"
  | "BADGE_DISPLAY"
  | "BOTS";

export type CatalogFeaturedOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "image_ASC"
  | "image_DESC"
  | "slot_ASC"
  | "slot_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type CatalogItemsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "club_ASC"
  | "club_DESC"
  | "available_ASC"
  | "available_DESC"
  | "limit_ASC"
  | "limit_DESC"
  | "discount_ASC"
  | "discount_DESC";

export type CatalogPageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "link_ASC"
  | "link_DESC"
  | "layout_ASC"
  | "layout_DESC"
  | "order_ASC"
  | "order_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "banner_ASC"
  | "banner_DESC"
  | "teaser_ASC"
  | "teaser_DESC"
  | "visible_ASC"
  | "visible_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "club_ASC"
  | "club_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "body_ASC"
  | "body_DESC"
  | "product_ASC"
  | "product_DESC";

export type Gender = "M" | "F";

export type HabboOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "online_ASC"
  | "online_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "home_ASC"
  | "home_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "appearOffline_ASC"
  | "appearOffline_DESC"
  | "allowTrade_ASC"
  | "allowTrade_DESC"
  | "allowGifts_ASC"
  | "allowGifts_DESC"
  | "allowMimic_ASC"
  | "allowMimic_DESC"
  | "allowFollow_ASC"
  | "allowFollow_DESC"
  | "allowWhisper_ASC"
  | "allowWhisper_DESC"
  | "allowFriendRequests_ASC"
  | "allowFriendRequests_DESC"
  | "allowBotSpeech_ASC"
  | "allowBotSpeech_DESC"
  | "allowPetSpeech_ASC"
  | "allowPetSpeech_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type roomType = "PUBLIC" | "LOCKED" | "PASSWORD" | "HIDDEN";

export type ChatlogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ChatlogConsoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ChatlogConsoleInvitationsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CurrenciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC";

export type HabboBadgesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "badge_ASC"
  | "badge_DESC";

export type HabboItemsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "item_ASC"
  | "item_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "native_ASC"
  | "native_DESC"
  | "code_ASC"
  | "code_DESC"
  | "enabled_ASC"
  | "enabled_DESC";

export type NavigatorCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "order_ASC"
  | "order_DESC";

export type NavigatorTabOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "order_ASC"
  | "order_DESC";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "body_ASC"
  | "body_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RankOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC"
  | "name_ASC"
  | "name_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "category_ASC"
  | "category_DESC"
  | "map_ASC"
  | "map_DESC"
  | "floorThickness_ASC"
  | "floorThickness_DESC"
  | "wallThickness_ASC"
  | "wallThickness_DESC"
  | "wallHeight_ASC"
  | "wallHeight_DESC"
  | "hideWalls_ASC"
  | "hideWalls_DESC"
  | "hideWired_ASC"
  | "hideWired_DESC"
  | "currentUsers_ASC"
  | "currentUsers_DESC"
  | "maxUsers_ASC"
  | "maxUsers_DESC"
  | "allowPets_ASC"
  | "allowPets_DESC"
  | "allowPetsEating_ASC"
  | "allowPetsEating_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "pin_ASC"
  | "pin_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BadgeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface BadgeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  OR?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  NOT?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
}

export type BanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  status?: Maybe<banStatus>;
  status_not?: Maybe<banStatus>;
  status_in?: Maybe<banStatus[] | banStatus>;
  status_not_in?: Maybe<banStatus[] | banStatus>;
  type?: Maybe<banType>;
  type_not?: Maybe<banType>;
  type_in?: Maybe<banType[] | banType>;
  type_not_in?: Maybe<banType[] | banType>;
  user?: Maybe<Int>;
  user_not?: Maybe<Int>;
  user_in?: Maybe<Int[] | Int>;
  user_not_in?: Maybe<Int[] | Int>;
  user_lt?: Maybe<Int>;
  user_lte?: Maybe<Int>;
  user_gt?: Maybe<Int>;
  user_gte?: Maybe<Int>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  machine?: Maybe<String>;
  machine_not?: Maybe<String>;
  machine_in?: Maybe<String[] | String>;
  machine_not_in?: Maybe<String[] | String>;
  machine_lt?: Maybe<String>;
  machine_lte?: Maybe<String>;
  machine_gt?: Maybe<String>;
  machine_gte?: Maybe<String>;
  machine_contains?: Maybe<String>;
  machine_not_contains?: Maybe<String>;
  machine_starts_with?: Maybe<String>;
  machine_not_starts_with?: Maybe<String>;
  machine_ends_with?: Maybe<String>;
  machine_not_ends_with?: Maybe<String>;
  by?: Maybe<Int>;
  by_not?: Maybe<Int>;
  by_in?: Maybe<Int[] | Int>;
  by_not_in?: Maybe<Int[] | Int>;
  by_lt?: Maybe<Int>;
  by_lte?: Maybe<Int>;
  by_gt?: Maybe<Int>;
  by_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BanWhereInput[] | BanWhereInput>;
  OR?: Maybe<BanWhereInput[] | BanWhereInput>;
  NOT?: Maybe<BanWhereInput[] | BanWhereInput>;
}

export type BotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  gender_not?: Maybe<Boolean>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  messages?: Maybe<String>;
  messages_not?: Maybe<String>;
  messages_in?: Maybe<String[] | String>;
  messages_not_in?: Maybe<String[] | String>;
  messages_lt?: Maybe<String>;
  messages_lte?: Maybe<String>;
  messages_gt?: Maybe<String>;
  messages_gte?: Maybe<String>;
  messages_contains?: Maybe<String>;
  messages_not_contains?: Maybe<String>;
  messages_starts_with?: Maybe<String>;
  messages_not_starts_with?: Maybe<String>;
  messages_ends_with?: Maybe<String>;
  messages_not_ends_with?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatBubble_not?: Maybe<Int>;
  chatBubble_in?: Maybe<Int[] | Int>;
  chatBubble_not_in?: Maybe<Int[] | Int>;
  chatBubble_lt?: Maybe<Int>;
  chatBubble_lte?: Maybe<Int>;
  chatBubble_gt?: Maybe<Int>;
  chatBubble_gte?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatAuto_not?: Maybe<Int>;
  chatAuto_in?: Maybe<Int[] | Int>;
  chatAuto_not_in?: Maybe<Int[] | Int>;
  chatAuto_lt?: Maybe<Int>;
  chatAuto_lte?: Maybe<Int>;
  chatAuto_gt?: Maybe<Int>;
  chatAuto_gte?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatRandom_not?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
  chatDelay_not?: Maybe<Int>;
  chatDelay_in?: Maybe<Int[] | Int>;
  chatDelay_not_in?: Maybe<Int[] | Int>;
  chatDelay_lt?: Maybe<Int>;
  chatDelay_lte?: Maybe<Int>;
  chatDelay_gt?: Maybe<Int>;
  chatDelay_gte?: Maybe<Int>;
  AND?: Maybe<BotWhereInput[] | BotWhereInput>;
  OR?: Maybe<BotWhereInput[] | BotWhereInput>;
  NOT?: Maybe<BotWhereInput[] | BotWhereInput>;
}

export type CatalogFeaturedWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CatalogFeaturedWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<CatalogPageWhereInput>;
  slot?: Maybe<Int>;
  slot_not?: Maybe<Int>;
  slot_in?: Maybe<Int[] | Int>;
  slot_not_in?: Maybe<Int[] | Int>;
  slot_lt?: Maybe<Int>;
  slot_lte?: Maybe<Int>;
  slot_gt?: Maybe<Int>;
  slot_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
  OR?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
  NOT?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
}

export interface CatalogPageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  parent?: Maybe<CatalogPageWhereInput>;
  layout?: Maybe<CatalogPageLayout>;
  layout_not?: Maybe<CatalogPageLayout>;
  layout_in?: Maybe<CatalogPageLayout[] | CatalogPageLayout>;
  layout_not_in?: Maybe<CatalogPageLayout[] | CatalogPageLayout>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  teaser?: Maybe<String>;
  teaser_not?: Maybe<String>;
  teaser_in?: Maybe<String[] | String>;
  teaser_not_in?: Maybe<String[] | String>;
  teaser_lt?: Maybe<String>;
  teaser_lte?: Maybe<String>;
  teaser_gt?: Maybe<String>;
  teaser_gte?: Maybe<String>;
  teaser_contains?: Maybe<String>;
  teaser_not_contains?: Maybe<String>;
  teaser_starts_with?: Maybe<String>;
  teaser_not_starts_with?: Maybe<String>;
  teaser_ends_with?: Maybe<String>;
  teaser_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  club?: Maybe<Boolean>;
  club_not?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  vip_not?: Maybe<Boolean>;
  AND?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  OR?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  NOT?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
}

export interface LanguageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  native?: Maybe<String>;
  native_not?: Maybe<String>;
  native_in?: Maybe<String[] | String>;
  native_not_in?: Maybe<String[] | String>;
  native_lt?: Maybe<String>;
  native_lte?: Maybe<String>;
  native_gt?: Maybe<String>;
  native_gte?: Maybe<String>;
  native_contains?: Maybe<String>;
  native_not_contains?: Maybe<String>;
  native_starts_with?: Maybe<String>;
  native_not_starts_with?: Maybe<String>;
  native_ends_with?: Maybe<String>;
  native_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  AND?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  OR?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  NOT?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
}

export type CatalogItemsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CatalogItemsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<CatalogPageWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  club?: Maybe<Boolean>;
  club_not?: Maybe<Boolean>;
  available?: Maybe<Int>;
  available_not?: Maybe<Int>;
  available_in?: Maybe<Int[] | Int>;
  available_not_in?: Maybe<Int[] | Int>;
  available_lt?: Maybe<Int>;
  available_lte?: Maybe<Int>;
  available_gt?: Maybe<Int>;
  available_gte?: Maybe<Int>;
  limit?: Maybe<Int>;
  limit_not?: Maybe<Int>;
  limit_in?: Maybe<Int[] | Int>;
  limit_not_in?: Maybe<Int[] | Int>;
  limit_lt?: Maybe<Int>;
  limit_lte?: Maybe<Int>;
  limit_gt?: Maybe<Int>;
  limit_gte?: Maybe<Int>;
  discount?: Maybe<Boolean>;
  discount_not?: Maybe<Boolean>;
  AND?: Maybe<CatalogItemsWhereInput[] | CatalogItemsWhereInput>;
  OR?: Maybe<CatalogItemsWhereInput[] | CatalogItemsWhereInput>;
  NOT?: Maybe<CatalogItemsWhereInput[] | CatalogItemsWhereInput>;
}

export type CatalogPageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  link?: Maybe<String>;
}>;

export type ChatlogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  vip?: Maybe<Int>;
  vip_not?: Maybe<Int>;
  vip_in?: Maybe<Int[] | Int>;
  vip_not_in?: Maybe<Int[] | Int>;
  vip_lt?: Maybe<Int>;
  vip_lte?: Maybe<Int>;
  vip_gt?: Maybe<Int>;
  vip_gte?: Maybe<Int>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  verified_not?: Maybe<Int>;
  verified_in?: Maybe<Int[] | Int>;
  verified_not_in?: Maybe<Int[] | Int>;
  verified_lt?: Maybe<Int>;
  verified_lte?: Maybe<Int>;
  verified_gt?: Maybe<Int>;
  verified_gte?: Maybe<Int>;
  home?: Maybe<Int>;
  home_not?: Maybe<Int>;
  home_in?: Maybe<Int[] | Int>;
  home_not_in?: Maybe<Int[] | Int>;
  home_lt?: Maybe<Int>;
  home_lte?: Maybe<Int>;
  home_gt?: Maybe<Int>;
  home_gte?: Maybe<Int>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  appearOffline_not?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowTrade_not?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowGifts_not?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowMimic_not?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowFollow_not?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowWhisper_not?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowFriendRequests_not?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowBotSpeech_not?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
  allowPetSpeech_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HabboWhereInput[] | HabboWhereInput>;
  OR?: Maybe<HabboWhereInput[] | HabboWhereInput>;
  NOT?: Maybe<HabboWhereInput[] | HabboWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  pin?: Maybe<Int>;
  pin_not?: Maybe<Int>;
  pin_in?: Maybe<Int[] | Int>;
  pin_not_in?: Maybe<Int[] | Int>;
  pin_lt?: Maybe<Int>;
  pin_lte?: Maybe<Int>;
  pin_gt?: Maybe<Int>;
  pin_gte?: Maybe<Int>;
  habbos_every?: Maybe<HabboWhereInput>;
  habbos_some?: Maybe<HabboWhereInput>;
  habbos_none?: Maybe<HabboWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChatlogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  habbo?: Maybe<HabboWhereInput>;
  room?: Maybe<RoomWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
  OR?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
  NOT?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
}

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<roomType>;
  type_not?: Maybe<roomType>;
  type_in?: Maybe<roomType[] | roomType>;
  type_not_in?: Maybe<roomType[] | roomType>;
  category?: Maybe<Int>;
  category_not?: Maybe<Int>;
  category_in?: Maybe<Int[] | Int>;
  category_not_in?: Maybe<Int[] | Int>;
  category_lt?: Maybe<Int>;
  category_lte?: Maybe<Int>;
  category_gt?: Maybe<Int>;
  category_gte?: Maybe<Int>;
  owner?: Maybe<HabboWhereInput>;
  floorThickness?: Maybe<Float>;
  floorThickness_not?: Maybe<Float>;
  floorThickness_in?: Maybe<Float[] | Float>;
  floorThickness_not_in?: Maybe<Float[] | Float>;
  floorThickness_lt?: Maybe<Float>;
  floorThickness_lte?: Maybe<Float>;
  floorThickness_gt?: Maybe<Float>;
  floorThickness_gte?: Maybe<Float>;
  wallThickness?: Maybe<Float>;
  wallThickness_not?: Maybe<Float>;
  wallThickness_in?: Maybe<Float[] | Float>;
  wallThickness_not_in?: Maybe<Float[] | Float>;
  wallThickness_lt?: Maybe<Float>;
  wallThickness_lte?: Maybe<Float>;
  wallThickness_gt?: Maybe<Float>;
  wallThickness_gte?: Maybe<Float>;
  wallHeight?: Maybe<Float>;
  wallHeight_not?: Maybe<Float>;
  wallHeight_in?: Maybe<Float[] | Float>;
  wallHeight_not_in?: Maybe<Float[] | Float>;
  wallHeight_lt?: Maybe<Float>;
  wallHeight_lte?: Maybe<Float>;
  wallHeight_gt?: Maybe<Float>;
  wallHeight_gte?: Maybe<Float>;
  hideWalls?: Maybe<Boolean>;
  hideWalls_not?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  hideWired_not?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  currentUsers_not?: Maybe<Int>;
  currentUsers_in?: Maybe<Int[] | Int>;
  currentUsers_not_in?: Maybe<Int[] | Int>;
  currentUsers_lt?: Maybe<Int>;
  currentUsers_lte?: Maybe<Int>;
  currentUsers_gt?: Maybe<Int>;
  currentUsers_gte?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  maxUsers_not?: Maybe<Int>;
  maxUsers_in?: Maybe<Int[] | Int>;
  maxUsers_not_in?: Maybe<Int[] | Int>;
  maxUsers_lt?: Maybe<Int>;
  maxUsers_lte?: Maybe<Int>;
  maxUsers_gt?: Maybe<Int>;
  maxUsers_gte?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPets_not?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  allowPetsEating_not?: Maybe<Boolean>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export type ChatlogConsoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChatlogConsoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  from?: Maybe<HabboWhereInput>;
  to?: Maybe<HabboWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
  OR?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
  NOT?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
}

export type ChatlogConsoleInvitationsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChatlogConsoleInvitationsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  from?: Maybe<HabboWhereInput>;
  to?: Maybe<HabboWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  room?: Maybe<RoomWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
  OR?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
  NOT?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
}

export type CurrenciesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CurrenciesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Int>;
  default_not?: Maybe<Int>;
  default_in?: Maybe<Int[] | Int>;
  default_not_in?: Maybe<Int[] | Int>;
  default_lt?: Maybe<Int>;
  default_lte?: Maybe<Int>;
  default_gt?: Maybe<Int>;
  default_gte?: Maybe<Int>;
  AND?: Maybe<CurrenciesWhereInput[] | CurrenciesWhereInput>;
  OR?: Maybe<CurrenciesWhereInput[] | CurrenciesWhereInput>;
  NOT?: Maybe<CurrenciesWhereInput[] | CurrenciesWhereInput>;
}

export type HabboWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export type HabboBadgesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboBadgesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  habbo?: Maybe<HabboWhereInput>;
  badge?: Maybe<String>;
  badge_not?: Maybe<String>;
  badge_in?: Maybe<String[] | String>;
  badge_not_in?: Maybe<String[] | String>;
  badge_lt?: Maybe<String>;
  badge_lte?: Maybe<String>;
  badge_gt?: Maybe<String>;
  badge_gte?: Maybe<String>;
  badge_contains?: Maybe<String>;
  badge_not_contains?: Maybe<String>;
  badge_starts_with?: Maybe<String>;
  badge_not_starts_with?: Maybe<String>;
  badge_ends_with?: Maybe<String>;
  badge_not_ends_with?: Maybe<String>;
  AND?: Maybe<HabboBadgesWhereInput[] | HabboBadgesWhereInput>;
  OR?: Maybe<HabboBadgesWhereInput[] | HabboBadgesWhereInput>;
  NOT?: Maybe<HabboBadgesWhereInput[] | HabboBadgesWhereInput>;
}

export type HabboItemsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboItemsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  habbo?: Maybe<HabboWhereInput>;
  item?: Maybe<String>;
  item_not?: Maybe<String>;
  item_in?: Maybe<String[] | String>;
  item_not_in?: Maybe<String[] | String>;
  item_lt?: Maybe<String>;
  item_lte?: Maybe<String>;
  item_gt?: Maybe<String>;
  item_gte?: Maybe<String>;
  item_contains?: Maybe<String>;
  item_not_contains?: Maybe<String>;
  item_starts_with?: Maybe<String>;
  item_not_starts_with?: Maybe<String>;
  item_ends_with?: Maybe<String>;
  item_not_ends_with?: Maybe<String>;
  AND?: Maybe<HabboItemsWhereInput[] | HabboItemsWhereInput>;
  OR?: Maybe<HabboItemsWhereInput[] | HabboItemsWhereInput>;
  NOT?: Maybe<HabboItemsWhereInput[] | HabboItemsWhereInput>;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export type NavigatorCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NavigatorCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  parent?: Maybe<NavigatorTabWhereInput>;
  AND?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
  OR?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
  NOT?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
}

export interface NavigatorTabWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  language?: Maybe<LanguageWhereInput>;
  categories_every?: Maybe<NavigatorCategoryWhereInput>;
  categories_some?: Maybe<NavigatorCategoryWhereInput>;
  categories_none?: Maybe<NavigatorCategoryWhereInput>;
  AND?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
  OR?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
  NOT?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
}

export type NavigatorTabWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export type RankWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RankWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RankWhereInput[] | RankWhereInput>;
  OR?: Maybe<RankWhereInput[] | RankWhereInput>;
  NOT?: Maybe<RankWhereInput[] | RankWhereInput>;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BadgeCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  description?: Maybe<String>;
}

export interface BadgeUpdateInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BadgeUpdateManyMutationInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BanCreateInput {
  id?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BanUpdateInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BanUpdateManyMutationInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BotCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotCreatestateInput>;
  action?: Maybe<BotCreateactionInput>;
  position?: Maybe<BotCreatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface BotCreatestateInput {
  set?: Maybe<String[] | String>;
}

export interface BotCreateactionInput {
  set?: Maybe<String[] | String>;
}

export interface BotCreatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface BotUpdateInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface BotUpdatestateInput {
  set?: Maybe<String[] | String>;
}

export interface BotUpdateactionInput {
  set?: Maybe<String[] | String>;
}

export interface BotUpdatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface BotUpdateManyMutationInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface CatalogFeaturedCreateInput {
  id?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<CatalogPageCreateOneInput>;
  slot?: Maybe<Int>;
}

export interface CatalogPageCreateOneInput {
  create?: Maybe<CatalogPageCreateInput>;
  connect?: Maybe<CatalogPageWhereUniqueInput>;
}

export interface CatalogPageCreateInput {
  id?: Maybe<ID_Input>;
  link: String;
  parent?: Maybe<CatalogPageCreateOneInput>;
  layout?: Maybe<CatalogPageLayout>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  language?: Maybe<LanguageCreateOneInput>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  banner?: Maybe<String>;
  teaser?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<Json>;
  product?: Maybe<Json>;
}

export interface LanguageCreateOneInput {
  create?: Maybe<LanguageCreateInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface LanguageCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  native?: Maybe<String>;
  code: String;
  enabled?: Maybe<Boolean>;
}

export interface CatalogFeaturedUpdateInput {
  caption?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<CatalogPageUpdateOneInput>;
  slot?: Maybe<Int>;
}

export interface CatalogPageUpdateOneInput {
  create?: Maybe<CatalogPageCreateInput>;
  update?: Maybe<CatalogPageUpdateDataInput>;
  upsert?: Maybe<CatalogPageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CatalogPageWhereUniqueInput>;
}

export interface CatalogPageUpdateDataInput {
  link?: Maybe<String>;
  parent?: Maybe<CatalogPageUpdateOneInput>;
  layout?: Maybe<CatalogPageLayout>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneInput>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  banner?: Maybe<String>;
  teaser?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<Json>;
  product?: Maybe<Json>;
}

export interface LanguageUpdateOneInput {
  create?: Maybe<LanguageCreateInput>;
  update?: Maybe<LanguageUpdateDataInput>;
  upsert?: Maybe<LanguageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface LanguageUpdateDataInput {
  name?: Maybe<String>;
  native?: Maybe<String>;
  code?: Maybe<String>;
  enabled?: Maybe<Boolean>;
}

export interface LanguageUpsertNestedInput {
  update: LanguageUpdateDataInput;
  create: LanguageCreateInput;
}

export interface CatalogPageUpsertNestedInput {
  update: CatalogPageUpdateDataInput;
  create: CatalogPageCreateInput;
}

export interface CatalogFeaturedUpdateManyMutationInput {
  caption?: Maybe<String>;
  image?: Maybe<String>;
  slot?: Maybe<Int>;
}

export interface CatalogItemsCreateInput {
  id?: Maybe<ID_Input>;
  page?: Maybe<CatalogPageCreateOneInput>;
  name: String;
  amount?: Maybe<Int>;
  club?: Maybe<Boolean>;
  available?: Maybe<Int>;
  limit?: Maybe<Int>;
  discount?: Maybe<Boolean>;
}

export interface CatalogItemsUpdateInput {
  page?: Maybe<CatalogPageUpdateOneInput>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  club?: Maybe<Boolean>;
  available?: Maybe<Int>;
  limit?: Maybe<Int>;
  discount?: Maybe<Boolean>;
}

export interface CatalogItemsUpdateManyMutationInput {
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  club?: Maybe<Boolean>;
  available?: Maybe<Int>;
  limit?: Maybe<Int>;
  discount?: Maybe<Boolean>;
}

export interface CatalogPageUpdateInput {
  link?: Maybe<String>;
  parent?: Maybe<CatalogPageUpdateOneInput>;
  layout?: Maybe<CatalogPageLayout>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneInput>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  banner?: Maybe<String>;
  teaser?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<Json>;
  product?: Maybe<Json>;
}

export interface CatalogPageUpdateManyMutationInput {
  link?: Maybe<String>;
  layout?: Maybe<CatalogPageLayout>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  banner?: Maybe<String>;
  teaser?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<Json>;
  product?: Maybe<Json>;
}

export interface ChatlogCreateInput {
  id?: Maybe<ID_Input>;
  habbo: HabboCreateOneInput;
  room: RoomCreateOneInput;
  message?: Maybe<String>;
}

export interface HabboCreateOneInput {
  create?: Maybe<HabboCreateInput>;
  connect?: Maybe<HabboWhereUniqueInput>;
}

export interface HabboCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutHabbosInput;
  username: String;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutHabbosInput {
  create?: Maybe<UserCreateWithoutHabbosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutHabbosInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface RoomCreateOneInput {
  create?: Maybe<RoomCreateInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<HabboCreateOneInput>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Float>;
  wallThickness?: Maybe<Float>;
  wallHeight?: Maybe<Float>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
}

export interface ChatlogUpdateInput {
  habbo?: Maybe<HabboUpdateOneRequiredInput>;
  room?: Maybe<RoomUpdateOneRequiredInput>;
  message?: Maybe<String>;
}

export interface HabboUpdateOneRequiredInput {
  create?: Maybe<HabboCreateInput>;
  update?: Maybe<HabboUpdateDataInput>;
  upsert?: Maybe<HabboUpsertNestedInput>;
  connect?: Maybe<HabboWhereUniqueInput>;
}

export interface HabboUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutHabbosInput>;
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredWithoutHabbosInput {
  create?: Maybe<UserCreateWithoutHabbosInput>;
  update?: Maybe<UserUpdateWithoutHabbosDataInput>;
  upsert?: Maybe<UserUpsertWithoutHabbosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutHabbosDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface UserUpsertWithoutHabbosInput {
  update: UserUpdateWithoutHabbosDataInput;
  create: UserCreateWithoutHabbosInput;
}

export interface HabboUpsertNestedInput {
  update: HabboUpdateDataInput;
  create: HabboCreateInput;
}

export interface RoomUpdateOneRequiredInput {
  create?: Maybe<RoomCreateInput>;
  update?: Maybe<RoomUpdateDataInput>;
  upsert?: Maybe<RoomUpsertNestedInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<HabboUpdateOneInput>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Float>;
  wallThickness?: Maybe<Float>;
  wallHeight?: Maybe<Float>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
}

export interface HabboUpdateOneInput {
  create?: Maybe<HabboCreateInput>;
  update?: Maybe<HabboUpdateDataInput>;
  upsert?: Maybe<HabboUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<HabboWhereUniqueInput>;
}

export interface RoomUpsertNestedInput {
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface ChatlogUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface ChatlogConsoleCreateInput {
  id?: Maybe<ID_Input>;
  from: HabboCreateOneInput;
  to: HabboCreateOneInput;
  message?: Maybe<String>;
}

export interface ChatlogConsoleUpdateInput {
  from?: Maybe<HabboUpdateOneRequiredInput>;
  to?: Maybe<HabboUpdateOneRequiredInput>;
  message?: Maybe<String>;
}

export interface ChatlogConsoleUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface ChatlogConsoleInvitationsCreateInput {
  id?: Maybe<ID_Input>;
  from: HabboCreateOneInput;
  to: HabboCreateOneInput;
  message?: Maybe<String>;
  room: RoomCreateOneInput;
}

export interface ChatlogConsoleInvitationsUpdateInput {
  from?: Maybe<HabboUpdateOneRequiredInput>;
  to?: Maybe<HabboUpdateOneRequiredInput>;
  message?: Maybe<String>;
  room?: Maybe<RoomUpdateOneRequiredInput>;
}

export interface ChatlogConsoleInvitationsUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface CurrenciesCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  default?: Maybe<Int>;
}

export interface CurrenciesUpdateInput {
  name?: Maybe<String>;
  default?: Maybe<Int>;
}

export interface CurrenciesUpdateManyMutationInput {
  name?: Maybe<String>;
  default?: Maybe<Int>;
}

export interface HabboUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutHabbosInput>;
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboUpdateManyMutationInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboBadgesCreateInput {
  id?: Maybe<ID_Input>;
  habbo: HabboCreateOneInput;
  badge: String;
}

export interface HabboBadgesUpdateInput {
  habbo?: Maybe<HabboUpdateOneRequiredInput>;
  badge?: Maybe<String>;
}

export interface HabboBadgesUpdateManyMutationInput {
  badge?: Maybe<String>;
}

export interface HabboItemsCreateInput {
  id?: Maybe<ID_Input>;
  habbo: HabboCreateOneInput;
  item?: Maybe<String>;
}

export interface HabboItemsUpdateInput {
  habbo?: Maybe<HabboUpdateOneRequiredInput>;
  item?: Maybe<String>;
}

export interface HabboItemsUpdateManyMutationInput {
  item?: Maybe<String>;
}

export interface LanguageUpdateInput {
  name?: Maybe<String>;
  native?: Maybe<String>;
  code?: Maybe<String>;
  enabled?: Maybe<Boolean>;
}

export interface LanguageUpdateManyMutationInput {
  name?: Maybe<String>;
  native?: Maybe<String>;
  code?: Maybe<String>;
  enabled?: Maybe<Boolean>;
}

export interface NavigatorCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
  parent?: Maybe<NavigatorTabCreateOneWithoutCategoriesInput>;
}

export interface NavigatorTabCreateOneWithoutCategoriesInput {
  create?: Maybe<NavigatorTabCreateWithoutCategoriesInput>;
  connect?: Maybe<NavigatorTabWhereUniqueInput>;
}

export interface NavigatorTabCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
  language?: Maybe<LanguageCreateOneInput>;
}

export interface NavigatorCategoryUpdateInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
  parent?: Maybe<NavigatorTabUpdateOneWithoutCategoriesInput>;
}

export interface NavigatorTabUpdateOneWithoutCategoriesInput {
  create?: Maybe<NavigatorTabCreateWithoutCategoriesInput>;
  update?: Maybe<NavigatorTabUpdateWithoutCategoriesDataInput>;
  upsert?: Maybe<NavigatorTabUpsertWithoutCategoriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NavigatorTabWhereUniqueInput>;
}

export interface NavigatorTabUpdateWithoutCategoriesDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
  language?: Maybe<LanguageUpdateOneInput>;
}

export interface NavigatorTabUpsertWithoutCategoriesInput {
  update: NavigatorTabUpdateWithoutCategoriesDataInput;
  create: NavigatorTabCreateWithoutCategoriesInput;
}

export interface NavigatorCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface NavigatorTabCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
  language?: Maybe<LanguageCreateOneInput>;
  categories?: Maybe<NavigatorCategoryCreateManyWithoutParentInput>;
}

export interface NavigatorCategoryCreateManyWithoutParentInput {
  create?: Maybe<
    | NavigatorCategoryCreateWithoutParentInput[]
    | NavigatorCategoryCreateWithoutParentInput
  >;
  connect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
}

export interface NavigatorCategoryCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface NavigatorTabUpdateInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
  language?: Maybe<LanguageUpdateOneInput>;
  categories?: Maybe<NavigatorCategoryUpdateManyWithoutParentInput>;
}

export interface NavigatorCategoryUpdateManyWithoutParentInput {
  create?: Maybe<
    | NavigatorCategoryCreateWithoutParentInput[]
    | NavigatorCategoryCreateWithoutParentInput
  >;
  delete?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  connect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  set?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  disconnect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput[]
    | NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput[]
    | NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | NavigatorCategoryUpdateManyWithWhereNestedInput[]
    | NavigatorCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput;
  data: NavigatorCategoryUpdateWithoutParentDataInput;
}

export interface NavigatorCategoryUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput;
  update: NavigatorCategoryUpdateWithoutParentDataInput;
  create: NavigatorCategoryCreateWithoutParentInput;
}

export interface NavigatorCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  OR?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  NOT?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
}

export interface NavigatorCategoryUpdateManyWithWhereNestedInput {
  where: NavigatorCategoryScalarWhereInput;
  data: NavigatorCategoryUpdateManyDataInput;
}

export interface NavigatorCategoryUpdateManyDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface NavigatorTabUpdateManyMutationInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface NewsCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboCreateManyWithoutUserInput>;
}

export interface HabboCreateManyWithoutUserInput {
  create?: Maybe<HabboCreateWithoutUserInput[] | HabboCreateWithoutUserInput>;
  connect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
}

export interface HabboCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  username: String;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface NewsUpdateInput {
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboUpdateManyWithoutUserInput>;
}

export interface HabboUpdateManyWithoutUserInput {
  create?: Maybe<HabboCreateWithoutUserInput[] | HabboCreateWithoutUserInput>;
  delete?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  connect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  set?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  disconnect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  update?: Maybe<
    | HabboUpdateWithWhereUniqueWithoutUserInput[]
    | HabboUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | HabboUpsertWithWhereUniqueWithoutUserInput[]
    | HabboUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  updateMany?: Maybe<
    HabboUpdateManyWithWhereNestedInput[] | HabboUpdateManyWithWhereNestedInput
  >;
}

export interface HabboUpdateWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput;
  data: HabboUpdateWithoutUserDataInput;
}

export interface HabboUpdateWithoutUserDataInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboUpsertWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput;
  update: HabboUpdateWithoutUserDataInput;
  create: HabboCreateWithoutUserInput;
}

export interface HabboScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  vip?: Maybe<Int>;
  vip_not?: Maybe<Int>;
  vip_in?: Maybe<Int[] | Int>;
  vip_not_in?: Maybe<Int[] | Int>;
  vip_lt?: Maybe<Int>;
  vip_lte?: Maybe<Int>;
  vip_gt?: Maybe<Int>;
  vip_gte?: Maybe<Int>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  verified_not?: Maybe<Int>;
  verified_in?: Maybe<Int[] | Int>;
  verified_not_in?: Maybe<Int[] | Int>;
  verified_lt?: Maybe<Int>;
  verified_lte?: Maybe<Int>;
  verified_gt?: Maybe<Int>;
  verified_gte?: Maybe<Int>;
  home?: Maybe<Int>;
  home_not?: Maybe<Int>;
  home_in?: Maybe<Int[] | Int>;
  home_not_in?: Maybe<Int[] | Int>;
  home_lt?: Maybe<Int>;
  home_lte?: Maybe<Int>;
  home_gt?: Maybe<Int>;
  home_gte?: Maybe<Int>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  appearOffline_not?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowTrade_not?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowGifts_not?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowMimic_not?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowFollow_not?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowWhisper_not?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowFriendRequests_not?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowBotSpeech_not?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
  allowPetSpeech_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  OR?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  NOT?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
}

export interface HabboUpdateManyWithWhereNestedInput {
  where: HabboScalarWhereInput;
  data: HabboUpdateManyDataInput;
}

export interface HabboUpdateManyDataInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface NewsUpdateManyMutationInput {
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
}

export interface RankCreateInput {
  id?: Maybe<ID_Input>;
  order: Int;
  name: String;
}

export interface RankUpdateInput {
  order?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface RankUpdateManyMutationInput {
  order?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface RoomUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<HabboUpdateOneInput>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Float>;
  wallThickness?: Maybe<Float>;
  wallHeight?: Maybe<Float>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
}

export interface RoomUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Float>;
  wallThickness?: Maybe<Float>;
  wallHeight?: Maybe<Float>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface BadgeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BadgeWhereInput>;
  AND?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  OR?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  NOT?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
}

export interface BanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BanWhereInput>;
  AND?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  OR?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  NOT?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
}

export interface BotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BotWhereInput>;
  AND?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  OR?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  NOT?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
}

export interface CatalogFeaturedSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogFeaturedWhereInput>;
  AND?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
}

export interface CatalogItemsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogItemsWhereInput>;
  AND?: Maybe<
    CatalogItemsSubscriptionWhereInput[] | CatalogItemsSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogItemsSubscriptionWhereInput[] | CatalogItemsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogItemsSubscriptionWhereInput[] | CatalogItemsSubscriptionWhereInput
  >;
}

export interface CatalogPageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogPageWhereInput>;
  AND?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
}

export interface ChatlogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogWhereInput>;
  AND?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
  OR?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
  NOT?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
}

export interface ChatlogConsoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogConsoleWhereInput>;
  AND?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
}

export interface ChatlogConsoleInvitationsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogConsoleInvitationsWhereInput>;
  AND?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
}

export interface CurrenciesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CurrenciesWhereInput>;
  AND?: Maybe<
    CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput
  >;
  OR?: Maybe<
    CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput
  >;
}

export interface HabboSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HabboWhereInput>;
  AND?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
  OR?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
  NOT?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
}

export interface HabboBadgesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HabboBadgesWhereInput>;
  AND?: Maybe<
    HabboBadgesSubscriptionWhereInput[] | HabboBadgesSubscriptionWhereInput
  >;
  OR?: Maybe<
    HabboBadgesSubscriptionWhereInput[] | HabboBadgesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    HabboBadgesSubscriptionWhereInput[] | HabboBadgesSubscriptionWhereInput
  >;
}

export interface HabboItemsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HabboItemsWhereInput>;
  AND?: Maybe<
    HabboItemsSubscriptionWhereInput[] | HabboItemsSubscriptionWhereInput
  >;
  OR?: Maybe<
    HabboItemsSubscriptionWhereInput[] | HabboItemsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    HabboItemsSubscriptionWhereInput[] | HabboItemsSubscriptionWhereInput
  >;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
  OR?: Maybe<LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput>;
  NOT?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
}

export interface NavigatorCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NavigatorCategoryWhereInput>;
  AND?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
}

export interface NavigatorTabSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NavigatorTabWhereInput>;
  AND?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
  OR?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export interface RankSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RankWhereInput>;
  AND?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  OR?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  NOT?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Badge {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePromise extends Promise<Badge>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeSubscription
  extends Promise<AsyncIterator<Badge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BadgeNullablePromise
  extends Promise<Badge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeConnection {
  pageInfo: PageInfo;
  edges: BadgeEdge[];
}

export interface BadgeConnectionPromise
  extends Promise<BadgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BadgeEdge>>() => T;
  aggregate: <T = AggregateBadgePromise>() => T;
}

export interface BadgeConnectionSubscription
  extends Promise<AsyncIterator<BadgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BadgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBadgeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BadgeEdge {
  node: Badge;
  cursor: String;
}

export interface BadgeEdgePromise extends Promise<BadgeEdge>, Fragmentable {
  node: <T = BadgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BadgeEdgeSubscription
  extends Promise<AsyncIterator<BadgeEdge>>,
    Fragmentable {
  node: <T = BadgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBadge {
  count: Int;
}

export interface AggregateBadgePromise
  extends Promise<AggregateBadge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBadgeSubscription
  extends Promise<AsyncIterator<AggregateBadge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Ban {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPromise extends Promise<Ban>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanSubscription
  extends Promise<AsyncIterator<Ban>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BanNullablePromise extends Promise<Ban | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanConnection {
  pageInfo: PageInfo;
  edges: BanEdge[];
}

export interface BanConnectionPromise
  extends Promise<BanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BanEdge>>() => T;
  aggregate: <T = AggregateBanPromise>() => T;
}

export interface BanConnectionSubscription
  extends Promise<AsyncIterator<BanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBanSubscription>() => T;
}

export interface BanEdge {
  node: Ban;
  cursor: String;
}

export interface BanEdgePromise extends Promise<BanEdge>, Fragmentable {
  node: <T = BanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BanEdgeSubscription
  extends Promise<AsyncIterator<BanEdge>>,
    Fragmentable {
  node: <T = BanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBan {
  count: Int;
}

export interface AggregateBanPromise
  extends Promise<AggregateBan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBanSubscription
  extends Promise<AsyncIterator<AggregateBan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Bot {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPromise extends Promise<Bot>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotSubscription
  extends Promise<AsyncIterator<Bot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface BotNullablePromise extends Promise<Bot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotConnection {
  pageInfo: PageInfo;
  edges: BotEdge[];
}

export interface BotConnectionPromise
  extends Promise<BotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotEdge>>() => T;
  aggregate: <T = AggregateBotPromise>() => T;
}

export interface BotConnectionSubscription
  extends Promise<AsyncIterator<BotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSubscription>() => T;
}

export interface BotEdge {
  node: Bot;
  cursor: String;
}

export interface BotEdgePromise extends Promise<BotEdge>, Fragmentable {
  node: <T = BotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotEdgeSubscription
  extends Promise<AsyncIterator<BotEdge>>,
    Fragmentable {
  node: <T = BotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBot {
  count: Int;
}

export interface AggregateBotPromise
  extends Promise<AggregateBot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSubscription
  extends Promise<AsyncIterator<AggregateBot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogFeatured {
  id: ID_Output;
  caption?: String;
  image?: String;
  slot?: Int;
  updated?: DateTimeOutput;
}

export interface CatalogFeaturedPromise
  extends Promise<CatalogFeatured>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  link: <T = CatalogPagePromise>() => T;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface CatalogFeaturedSubscription
  extends Promise<AsyncIterator<CatalogFeatured>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: <T = CatalogPageSubscription>() => T;
  slot: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CatalogFeaturedNullablePromise
  extends Promise<CatalogFeatured | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  link: <T = CatalogPagePromise>() => T;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface CatalogPage {
  id: ID_Output;
  link: String;
  layout?: CatalogPageLayout;
  order?: Int;
  name?: String;
  description?: String;
  icon?: String;
  banner?: String;
  teaser?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: Json;
  product?: Json;
}

export interface CatalogPagePromise extends Promise<CatalogPage>, Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  parent: <T = CatalogPagePromise>() => T;
  layout: () => Promise<CatalogPageLayout>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  banner: () => Promise<String>;
  teaser: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<Json>;
  product: () => Promise<Json>;
}

export interface CatalogPageSubscription
  extends Promise<AsyncIterator<CatalogPage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  parent: <T = CatalogPageSubscription>() => T;
  layout: () => Promise<AsyncIterator<CatalogPageLayout>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  teaser: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<Json>>;
  product: () => Promise<AsyncIterator<Json>>;
}

export interface CatalogPageNullablePromise
  extends Promise<CatalogPage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  parent: <T = CatalogPagePromise>() => T;
  layout: () => Promise<CatalogPageLayout>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  banner: () => Promise<String>;
  teaser: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<Json>;
  product: () => Promise<Json>;
}

export interface Language {
  id: ID_Output;
  name?: String;
  native?: String;
  code: String;
  enabled?: Boolean;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  native: () => Promise<String>;
  code: () => Promise<String>;
  enabled: () => Promise<Boolean>;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  native: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
}

export interface LanguageNullablePromise
  extends Promise<Language | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  native: () => Promise<String>;
  code: () => Promise<String>;
  enabled: () => Promise<Boolean>;
}

export interface CatalogFeaturedConnection {
  pageInfo: PageInfo;
  edges: CatalogFeaturedEdge[];
}

export interface CatalogFeaturedConnectionPromise
  extends Promise<CatalogFeaturedConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogFeaturedEdge>>() => T;
  aggregate: <T = AggregateCatalogFeaturedPromise>() => T;
}

export interface CatalogFeaturedConnectionSubscription
  extends Promise<AsyncIterator<CatalogFeaturedConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogFeaturedEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogFeaturedSubscription>() => T;
}

export interface CatalogFeaturedEdge {
  node: CatalogFeatured;
  cursor: String;
}

export interface CatalogFeaturedEdgePromise
  extends Promise<CatalogFeaturedEdge>,
    Fragmentable {
  node: <T = CatalogFeaturedPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogFeaturedEdgeSubscription
  extends Promise<AsyncIterator<CatalogFeaturedEdge>>,
    Fragmentable {
  node: <T = CatalogFeaturedSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogFeatured {
  count: Int;
}

export interface AggregateCatalogFeaturedPromise
  extends Promise<AggregateCatalogFeatured>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogFeaturedSubscription
  extends Promise<AsyncIterator<AggregateCatalogFeatured>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItems {
  id: ID_Output;
  name: String;
  amount?: Int;
  club?: Boolean;
  available?: Int;
  limit?: Int;
  discount?: Boolean;
}

export interface CatalogItemsPromise
  extends Promise<CatalogItems>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = CatalogPagePromise>() => T;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  club: () => Promise<Boolean>;
  available: () => Promise<Int>;
  limit: () => Promise<Int>;
  discount: () => Promise<Boolean>;
}

export interface CatalogItemsSubscription
  extends Promise<AsyncIterator<CatalogItems>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = CatalogPageSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  available: () => Promise<AsyncIterator<Int>>;
  limit: () => Promise<AsyncIterator<Int>>;
  discount: () => Promise<AsyncIterator<Boolean>>;
}

export interface CatalogItemsNullablePromise
  extends Promise<CatalogItems | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = CatalogPagePromise>() => T;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  club: () => Promise<Boolean>;
  available: () => Promise<Int>;
  limit: () => Promise<Int>;
  discount: () => Promise<Boolean>;
}

export interface CatalogItemsConnection {
  pageInfo: PageInfo;
  edges: CatalogItemsEdge[];
}

export interface CatalogItemsConnectionPromise
  extends Promise<CatalogItemsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogItemsEdge>>() => T;
  aggregate: <T = AggregateCatalogItemsPromise>() => T;
}

export interface CatalogItemsConnectionSubscription
  extends Promise<AsyncIterator<CatalogItemsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogItemsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogItemsSubscription>() => T;
}

export interface CatalogItemsEdge {
  node: CatalogItems;
  cursor: String;
}

export interface CatalogItemsEdgePromise
  extends Promise<CatalogItemsEdge>,
    Fragmentable {
  node: <T = CatalogItemsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogItemsEdgeSubscription
  extends Promise<AsyncIterator<CatalogItemsEdge>>,
    Fragmentable {
  node: <T = CatalogItemsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogItems {
  count: Int;
}

export interface AggregateCatalogItemsPromise
  extends Promise<AggregateCatalogItems>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogItemsSubscription
  extends Promise<AsyncIterator<AggregateCatalogItems>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogPageConnection {
  pageInfo: PageInfo;
  edges: CatalogPageEdge[];
}

export interface CatalogPageConnectionPromise
  extends Promise<CatalogPageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogPageEdge>>() => T;
  aggregate: <T = AggregateCatalogPagePromise>() => T;
}

export interface CatalogPageConnectionSubscription
  extends Promise<AsyncIterator<CatalogPageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogPageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogPageSubscription>() => T;
}

export interface CatalogPageEdge {
  node: CatalogPage;
  cursor: String;
}

export interface CatalogPageEdgePromise
  extends Promise<CatalogPageEdge>,
    Fragmentable {
  node: <T = CatalogPagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogPageEdgeSubscription
  extends Promise<AsyncIterator<CatalogPageEdge>>,
    Fragmentable {
  node: <T = CatalogPageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogPage {
  count: Int;
}

export interface AggregateCatalogPagePromise
  extends Promise<AggregateCatalogPage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogPageSubscription
  extends Promise<AsyncIterator<AggregateCatalogPage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Chatlog {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogPromise extends Promise<Chatlog>, Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  room: <T = RoomPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogSubscription
  extends Promise<AsyncIterator<Chatlog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  habbo: <T = HabboSubscription>() => T;
  room: <T = RoomSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogNullablePromise
  extends Promise<Chatlog | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  room: <T = RoomPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Habbo {
  id: ID_Output;
  username: String;
  motto?: String;
  gender?: Gender;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  appearOffline?: Boolean;
  allowTrade?: Boolean;
  allowGifts?: Boolean;
  allowMimic?: Boolean;
  allowFollow?: Boolean;
  allowWhisper?: Boolean;
  allowFriendRequests?: Boolean;
  allowBotSpeech?: Boolean;
  allowPetSpeech?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface HabboPromise extends Promise<Habbo>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HabboSubscription
  extends Promise<AsyncIterator<Habbo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  username: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  appearOffline: () => Promise<AsyncIterator<Boolean>>;
  allowTrade: () => Promise<AsyncIterator<Boolean>>;
  allowGifts: () => Promise<AsyncIterator<Boolean>>;
  allowMimic: () => Promise<AsyncIterator<Boolean>>;
  allowFollow: () => Promise<AsyncIterator<Boolean>>;
  allowWhisper: () => Promise<AsyncIterator<Boolean>>;
  allowFriendRequests: () => Promise<AsyncIterator<Boolean>>;
  allowBotSpeech: () => Promise<AsyncIterator<Boolean>>;
  allowPetSpeech: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HabboNullablePromise
  extends Promise<Habbo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  email?: String;
  password?: String;
  pin?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  habbos: <T = FragmentableArray<Habbo>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  habbos: <T = Promise<AsyncIterator<HabboSubscription>>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  habbos: <T = FragmentableArray<Habbo>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Room {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  map?: Json;
  floorThickness?: Float;
  wallThickness?: Float;
  wallHeight?: Float;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  currentUsers?: Int;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: <T = HabboPromise>() => T;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Float>;
  wallThickness: () => Promise<Float>;
  wallHeight: () => Promise<Float>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: <T = HabboSubscription>() => T;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Float>>;
  wallThickness: () => Promise<AsyncIterator<Float>>;
  wallHeight: () => Promise<AsyncIterator<Float>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  currentUsers: () => Promise<AsyncIterator<Int>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: <T = HabboPromise>() => T;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Float>;
  wallThickness: () => Promise<Float>;
  wallHeight: () => Promise<Float>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
}

export interface ChatlogConnection {
  pageInfo: PageInfo;
  edges: ChatlogEdge[];
}

export interface ChatlogConnectionPromise
  extends Promise<ChatlogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogEdge>>() => T;
  aggregate: <T = AggregateChatlogPromise>() => T;
}

export interface ChatlogConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatlogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatlogSubscription>() => T;
}

export interface ChatlogEdge {
  node: Chatlog;
  cursor: String;
}

export interface ChatlogEdgePromise extends Promise<ChatlogEdge>, Fragmentable {
  node: <T = ChatlogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogEdgeSubscription
  extends Promise<AsyncIterator<ChatlogEdge>>,
    Fragmentable {
  node: <T = ChatlogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChatlog {
  count: Int;
}

export interface AggregateChatlogPromise
  extends Promise<AggregateChatlog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogSubscription
  extends Promise<AsyncIterator<AggregateChatlog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatlogConsole {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsolePromise
  extends Promise<ChatlogConsole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleSubscription
  extends Promise<AsyncIterator<ChatlogConsole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = HabboSubscription>() => T;
  to: <T = HabboSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleNullablePromise
  extends Promise<ChatlogConsole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleConnection {
  pageInfo: PageInfo;
  edges: ChatlogConsoleEdge[];
}

export interface ChatlogConsoleConnectionPromise
  extends Promise<ChatlogConsoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogConsoleEdge>>() => T;
  aggregate: <T = AggregateChatlogConsolePromise>() => T;
}

export interface ChatlogConsoleConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConsoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatlogConsoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatlogConsoleSubscription>() => T;
}

export interface ChatlogConsoleEdge {
  node: ChatlogConsole;
  cursor: String;
}

export interface ChatlogConsoleEdgePromise
  extends Promise<ChatlogConsoleEdge>,
    Fragmentable {
  node: <T = ChatlogConsolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogConsoleEdgeSubscription
  extends Promise<AsyncIterator<ChatlogConsoleEdge>>,
    Fragmentable {
  node: <T = ChatlogConsoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChatlogConsole {
  count: Int;
}

export interface AggregateChatlogConsolePromise
  extends Promise<AggregateChatlogConsole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogConsoleSubscription
  extends Promise<AsyncIterator<AggregateChatlogConsole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatlogConsoleInvitations {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsoleInvitationsPromise
  extends Promise<ChatlogConsoleInvitations>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  room: <T = RoomPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitations>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = HabboSubscription>() => T;
  to: <T = HabboSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  room: <T = RoomSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleInvitationsNullablePromise
  extends Promise<ChatlogConsoleInvitations | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  room: <T = RoomPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsConnection {
  pageInfo: PageInfo;
  edges: ChatlogConsoleInvitationsEdge[];
}

export interface ChatlogConsoleInvitationsConnectionPromise
  extends Promise<ChatlogConsoleInvitationsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogConsoleInvitationsEdge>>() => T;
  aggregate: <T = AggregateChatlogConsoleInvitationsPromise>() => T;
}

export interface ChatlogConsoleInvitationsConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ChatlogConsoleInvitationsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateChatlogConsoleInvitationsSubscription>() => T;
}

export interface ChatlogConsoleInvitationsEdge {
  node: ChatlogConsoleInvitations;
  cursor: String;
}

export interface ChatlogConsoleInvitationsEdgePromise
  extends Promise<ChatlogConsoleInvitationsEdge>,
    Fragmentable {
  node: <T = ChatlogConsoleInvitationsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogConsoleInvitationsEdgeSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsEdge>>,
    Fragmentable {
  node: <T = ChatlogConsoleInvitationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChatlogConsoleInvitations {
  count: Int;
}

export interface AggregateChatlogConsoleInvitationsPromise
  extends Promise<AggregateChatlogConsoleInvitations>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogConsoleInvitationsSubscription
  extends Promise<AsyncIterator<AggregateChatlogConsoleInvitations>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Currencies {
  id: ID_Output;
  name: String;
  default?: Int;
}

export interface CurrenciesPromise extends Promise<Currencies>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  default: () => Promise<Int>;
}

export interface CurrenciesSubscription
  extends Promise<AsyncIterator<Currencies>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Int>>;
}

export interface CurrenciesNullablePromise
  extends Promise<Currencies | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  default: () => Promise<Int>;
}

export interface CurrenciesConnection {
  pageInfo: PageInfo;
  edges: CurrenciesEdge[];
}

export interface CurrenciesConnectionPromise
  extends Promise<CurrenciesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrenciesEdge>>() => T;
  aggregate: <T = AggregateCurrenciesPromise>() => T;
}

export interface CurrenciesConnectionSubscription
  extends Promise<AsyncIterator<CurrenciesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrenciesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrenciesSubscription>() => T;
}

export interface CurrenciesEdge {
  node: Currencies;
  cursor: String;
}

export interface CurrenciesEdgePromise
  extends Promise<CurrenciesEdge>,
    Fragmentable {
  node: <T = CurrenciesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrenciesEdgeSubscription
  extends Promise<AsyncIterator<CurrenciesEdge>>,
    Fragmentable {
  node: <T = CurrenciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurrencies {
  count: Int;
}

export interface AggregateCurrenciesPromise
  extends Promise<AggregateCurrencies>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrenciesSubscription
  extends Promise<AsyncIterator<AggregateCurrencies>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HabboConnection {
  pageInfo: PageInfo;
  edges: HabboEdge[];
}

export interface HabboConnectionPromise
  extends Promise<HabboConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HabboEdge>>() => T;
  aggregate: <T = AggregateHabboPromise>() => T;
}

export interface HabboConnectionSubscription
  extends Promise<AsyncIterator<HabboConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HabboEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHabboSubscription>() => T;
}

export interface HabboEdge {
  node: Habbo;
  cursor: String;
}

export interface HabboEdgePromise extends Promise<HabboEdge>, Fragmentable {
  node: <T = HabboPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HabboEdgeSubscription
  extends Promise<AsyncIterator<HabboEdge>>,
    Fragmentable {
  node: <T = HabboSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHabbo {
  count: Int;
}

export interface AggregateHabboPromise
  extends Promise<AggregateHabbo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHabboSubscription
  extends Promise<AsyncIterator<AggregateHabbo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HabboBadges {
  id: ID_Output;
  badge: String;
}

export interface HabboBadgesPromise extends Promise<HabboBadges>, Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  badge: () => Promise<String>;
}

export interface HabboBadgesSubscription
  extends Promise<AsyncIterator<HabboBadges>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  habbo: <T = HabboSubscription>() => T;
  badge: () => Promise<AsyncIterator<String>>;
}

export interface HabboBadgesNullablePromise
  extends Promise<HabboBadges | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  badge: () => Promise<String>;
}

export interface HabboBadgesConnection {
  pageInfo: PageInfo;
  edges: HabboBadgesEdge[];
}

export interface HabboBadgesConnectionPromise
  extends Promise<HabboBadgesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HabboBadgesEdge>>() => T;
  aggregate: <T = AggregateHabboBadgesPromise>() => T;
}

export interface HabboBadgesConnectionSubscription
  extends Promise<AsyncIterator<HabboBadgesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HabboBadgesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHabboBadgesSubscription>() => T;
}

export interface HabboBadgesEdge {
  node: HabboBadges;
  cursor: String;
}

export interface HabboBadgesEdgePromise
  extends Promise<HabboBadgesEdge>,
    Fragmentable {
  node: <T = HabboBadgesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HabboBadgesEdgeSubscription
  extends Promise<AsyncIterator<HabboBadgesEdge>>,
    Fragmentable {
  node: <T = HabboBadgesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHabboBadges {
  count: Int;
}

export interface AggregateHabboBadgesPromise
  extends Promise<AggregateHabboBadges>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHabboBadgesSubscription
  extends Promise<AsyncIterator<AggregateHabboBadges>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HabboItems {
  id: ID_Output;
  item?: String;
}

export interface HabboItemsPromise extends Promise<HabboItems>, Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  item: () => Promise<String>;
}

export interface HabboItemsSubscription
  extends Promise<AsyncIterator<HabboItems>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  habbo: <T = HabboSubscription>() => T;
  item: () => Promise<AsyncIterator<String>>;
}

export interface HabboItemsNullablePromise
  extends Promise<HabboItems | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  item: () => Promise<String>;
}

export interface HabboItemsConnection {
  pageInfo: PageInfo;
  edges: HabboItemsEdge[];
}

export interface HabboItemsConnectionPromise
  extends Promise<HabboItemsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HabboItemsEdge>>() => T;
  aggregate: <T = AggregateHabboItemsPromise>() => T;
}

export interface HabboItemsConnectionSubscription
  extends Promise<AsyncIterator<HabboItemsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HabboItemsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHabboItemsSubscription>() => T;
}

export interface HabboItemsEdge {
  node: HabboItems;
  cursor: String;
}

export interface HabboItemsEdgePromise
  extends Promise<HabboItemsEdge>,
    Fragmentable {
  node: <T = HabboItemsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HabboItemsEdgeSubscription
  extends Promise<AsyncIterator<HabboItemsEdge>>,
    Fragmentable {
  node: <T = HabboItemsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHabboItems {
  count: Int;
}

export interface AggregateHabboItemsPromise
  extends Promise<AggregateHabboItems>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHabboItemsSubscription
  extends Promise<AsyncIterator<AggregateHabboItems>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorCategory {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorCategoryPromise
  extends Promise<NavigatorCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  parent: <T = NavigatorTabPromise>() => T;
}

export interface NavigatorCategorySubscription
  extends Promise<AsyncIterator<NavigatorCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  parent: <T = NavigatorTabSubscription>() => T;
}

export interface NavigatorCategoryNullablePromise
  extends Promise<NavigatorCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  parent: <T = NavigatorTabPromise>() => T;
}

export interface NavigatorTab {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorTabPromise
  extends Promise<NavigatorTab>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  language: <T = LanguagePromise>() => T;
  categories: <T = FragmentableArray<NavigatorCategory>>(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NavigatorTabSubscription
  extends Promise<AsyncIterator<NavigatorTab>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  language: <T = LanguageSubscription>() => T;
  categories: <
    T = Promise<AsyncIterator<NavigatorCategorySubscription>>
  >(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NavigatorTabNullablePromise
  extends Promise<NavigatorTab | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  language: <T = LanguagePromise>() => T;
  categories: <T = FragmentableArray<NavigatorCategory>>(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NavigatorCategoryConnection {
  pageInfo: PageInfo;
  edges: NavigatorCategoryEdge[];
}

export interface NavigatorCategoryConnectionPromise
  extends Promise<NavigatorCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NavigatorCategoryEdge>>() => T;
  aggregate: <T = AggregateNavigatorCategoryPromise>() => T;
}

export interface NavigatorCategoryConnectionSubscription
  extends Promise<AsyncIterator<NavigatorCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NavigatorCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNavigatorCategorySubscription>() => T;
}

export interface NavigatorCategoryEdge {
  node: NavigatorCategory;
  cursor: String;
}

export interface NavigatorCategoryEdgePromise
  extends Promise<NavigatorCategoryEdge>,
    Fragmentable {
  node: <T = NavigatorCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NavigatorCategoryEdgeSubscription
  extends Promise<AsyncIterator<NavigatorCategoryEdge>>,
    Fragmentable {
  node: <T = NavigatorCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNavigatorCategory {
  count: Int;
}

export interface AggregateNavigatorCategoryPromise
  extends Promise<AggregateNavigatorCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNavigatorCategorySubscription
  extends Promise<AsyncIterator<AggregateNavigatorCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorTabConnection {
  pageInfo: PageInfo;
  edges: NavigatorTabEdge[];
}

export interface NavigatorTabConnectionPromise
  extends Promise<NavigatorTabConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NavigatorTabEdge>>() => T;
  aggregate: <T = AggregateNavigatorTabPromise>() => T;
}

export interface NavigatorTabConnectionSubscription
  extends Promise<AsyncIterator<NavigatorTabConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NavigatorTabEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNavigatorTabSubscription>() => T;
}

export interface NavigatorTabEdge {
  node: NavigatorTab;
  cursor: String;
}

export interface NavigatorTabEdgePromise
  extends Promise<NavigatorTabEdge>,
    Fragmentable {
  node: <T = NavigatorTabPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NavigatorTabEdgeSubscription
  extends Promise<AsyncIterator<NavigatorTabEdge>>,
    Fragmentable {
  node: <T = NavigatorTabSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNavigatorTab {
  count: Int;
}

export interface AggregateNavigatorTabPromise
  extends Promise<AggregateNavigatorTab>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNavigatorTabSubscription
  extends Promise<AsyncIterator<AggregateNavigatorTab>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface News {
  id: ID_Output;
  title?: String;
  summary?: String;
  body?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Rank {
  id: ID_Output;
  order: Int;
  name: String;
}

export interface RankPromise extends Promise<Rank>, Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface RankSubscription
  extends Promise<AsyncIterator<Rank>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RankNullablePromise
  extends Promise<Rank | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface RankConnection {
  pageInfo: PageInfo;
  edges: RankEdge[];
}

export interface RankConnectionPromise
  extends Promise<RankConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RankEdge>>() => T;
  aggregate: <T = AggregateRankPromise>() => T;
}

export interface RankConnectionSubscription
  extends Promise<AsyncIterator<RankConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RankEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRankSubscription>() => T;
}

export interface RankEdge {
  node: Rank;
  cursor: String;
}

export interface RankEdgePromise extends Promise<RankEdge>, Fragmentable {
  node: <T = RankPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RankEdgeSubscription
  extends Promise<AsyncIterator<RankEdge>>,
    Fragmentable {
  node: <T = RankSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRank {
  count: Int;
}

export interface AggregateRankPromise
  extends Promise<AggregateRank>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRankSubscription
  extends Promise<AsyncIterator<AggregateRank>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BadgeSubscriptionPayload {
  mutation: MutationType;
  node: Badge;
  updatedFields: String[];
  previousValues: BadgePreviousValues;
}

export interface BadgeSubscriptionPayloadPromise
  extends Promise<BadgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BadgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BadgePreviousValuesPromise>() => T;
}

export interface BadgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BadgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BadgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BadgePreviousValuesSubscription>() => T;
}

export interface BadgePreviousValues {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePreviousValuesPromise
  extends Promise<BadgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgePreviousValuesSubscription
  extends Promise<AsyncIterator<BadgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BanSubscriptionPayload {
  mutation: MutationType;
  node: Ban;
  updatedFields: String[];
  previousValues: BanPreviousValues;
}

export interface BanSubscriptionPayloadPromise
  extends Promise<BanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BanPreviousValuesPromise>() => T;
}

export interface BanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BanPreviousValuesSubscription>() => T;
}

export interface BanPreviousValues {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPreviousValuesPromise
  extends Promise<BanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanPreviousValuesSubscription
  extends Promise<AsyncIterator<BanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BotSubscriptionPayload {
  mutation: MutationType;
  node: Bot;
  updatedFields: String[];
  previousValues: BotPreviousValues;
}

export interface BotSubscriptionPayloadPromise
  extends Promise<BotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotPreviousValuesPromise>() => T;
}

export interface BotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotPreviousValuesSubscription>() => T;
}

export interface BotPreviousValues {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPreviousValuesPromise
  extends Promise<BotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotPreviousValuesSubscription
  extends Promise<AsyncIterator<BotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogFeaturedSubscriptionPayload {
  mutation: MutationType;
  node: CatalogFeatured;
  updatedFields: String[];
  previousValues: CatalogFeaturedPreviousValues;
}

export interface CatalogFeaturedSubscriptionPayloadPromise
  extends Promise<CatalogFeaturedSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogFeaturedPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogFeaturedPreviousValuesPromise>() => T;
}

export interface CatalogFeaturedSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogFeaturedSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogFeaturedSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogFeaturedPreviousValuesSubscription>() => T;
}

export interface CatalogFeaturedPreviousValues {
  id: ID_Output;
  caption?: String;
  image?: String;
  slot?: Int;
  updated?: DateTimeOutput;
}

export interface CatalogFeaturedPreviousValuesPromise
  extends Promise<CatalogFeaturedPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface CatalogFeaturedPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogFeaturedPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  slot: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CatalogItemsSubscriptionPayload {
  mutation: MutationType;
  node: CatalogItems;
  updatedFields: String[];
  previousValues: CatalogItemsPreviousValues;
}

export interface CatalogItemsSubscriptionPayloadPromise
  extends Promise<CatalogItemsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogItemsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogItemsPreviousValuesPromise>() => T;
}

export interface CatalogItemsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogItemsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogItemsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogItemsPreviousValuesSubscription>() => T;
}

export interface CatalogItemsPreviousValues {
  id: ID_Output;
  name: String;
  amount?: Int;
  club?: Boolean;
  available?: Int;
  limit?: Int;
  discount?: Boolean;
}

export interface CatalogItemsPreviousValuesPromise
  extends Promise<CatalogItemsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  club: () => Promise<Boolean>;
  available: () => Promise<Int>;
  limit: () => Promise<Int>;
  discount: () => Promise<Boolean>;
}

export interface CatalogItemsPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogItemsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  available: () => Promise<AsyncIterator<Int>>;
  limit: () => Promise<AsyncIterator<Int>>;
  discount: () => Promise<AsyncIterator<Boolean>>;
}

export interface CatalogPageSubscriptionPayload {
  mutation: MutationType;
  node: CatalogPage;
  updatedFields: String[];
  previousValues: CatalogPagePreviousValues;
}

export interface CatalogPageSubscriptionPayloadPromise
  extends Promise<CatalogPageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogPagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogPagePreviousValuesPromise>() => T;
}

export interface CatalogPageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogPageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogPageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogPagePreviousValuesSubscription>() => T;
}

export interface CatalogPagePreviousValues {
  id: ID_Output;
  link: String;
  layout?: CatalogPageLayout;
  order?: Int;
  name?: String;
  description?: String;
  icon?: String;
  banner?: String;
  teaser?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: Json;
  product?: Json;
}

export interface CatalogPagePreviousValuesPromise
  extends Promise<CatalogPagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  layout: () => Promise<CatalogPageLayout>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  banner: () => Promise<String>;
  teaser: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<Json>;
  product: () => Promise<Json>;
}

export interface CatalogPagePreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogPagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  layout: () => Promise<AsyncIterator<CatalogPageLayout>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  teaser: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<Json>>;
  product: () => Promise<AsyncIterator<Json>>;
}

export interface ChatlogSubscriptionPayload {
  mutation: MutationType;
  node: Chatlog;
  updatedFields: String[];
  previousValues: ChatlogPreviousValues;
}

export interface ChatlogSubscriptionPayloadPromise
  extends Promise<ChatlogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogPreviousValuesPromise>() => T;
}

export interface ChatlogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatlogPreviousValuesSubscription>() => T;
}

export interface ChatlogPreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogPreviousValuesPromise
  extends Promise<ChatlogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleSubscriptionPayload {
  mutation: MutationType;
  node: ChatlogConsole;
  updatedFields: String[];
  previousValues: ChatlogConsolePreviousValues;
}

export interface ChatlogConsoleSubscriptionPayloadPromise
  extends Promise<ChatlogConsoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogConsolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogConsolePreviousValuesPromise>() => T;
}

export interface ChatlogConsoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogConsoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogConsoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatlogConsolePreviousValuesSubscription>() => T;
}

export interface ChatlogConsolePreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsolePreviousValuesPromise
  extends Promise<ChatlogConsolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsolePreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogConsolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleInvitationsSubscriptionPayload {
  mutation: MutationType;
  node: ChatlogConsoleInvitations;
  updatedFields: String[];
  previousValues: ChatlogConsoleInvitationsPreviousValues;
}

export interface ChatlogConsoleInvitationsSubscriptionPayloadPromise
  extends Promise<ChatlogConsoleInvitationsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogConsoleInvitationsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogConsoleInvitationsPreviousValuesPromise>() => T;
}

export interface ChatlogConsoleInvitationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogConsoleInvitationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ChatlogConsoleInvitationsPreviousValuesSubscription
  >() => T;
}

export interface ChatlogConsoleInvitationsPreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsoleInvitationsPreviousValuesPromise
  extends Promise<ChatlogConsoleInvitationsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrenciesSubscriptionPayload {
  mutation: MutationType;
  node: Currencies;
  updatedFields: String[];
  previousValues: CurrenciesPreviousValues;
}

export interface CurrenciesSubscriptionPayloadPromise
  extends Promise<CurrenciesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrenciesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrenciesPreviousValuesPromise>() => T;
}

export interface CurrenciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrenciesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrenciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrenciesPreviousValuesSubscription>() => T;
}

export interface CurrenciesPreviousValues {
  id: ID_Output;
  name: String;
  default?: Int;
}

export interface CurrenciesPreviousValuesPromise
  extends Promise<CurrenciesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  default: () => Promise<Int>;
}

export interface CurrenciesPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrenciesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Int>>;
}

export interface HabboSubscriptionPayload {
  mutation: MutationType;
  node: Habbo;
  updatedFields: String[];
  previousValues: HabboPreviousValues;
}

export interface HabboSubscriptionPayloadPromise
  extends Promise<HabboSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HabboPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HabboPreviousValuesPromise>() => T;
}

export interface HabboSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HabboSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HabboSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HabboPreviousValuesSubscription>() => T;
}

export interface HabboPreviousValues {
  id: ID_Output;
  username: String;
  motto?: String;
  gender?: Gender;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  appearOffline?: Boolean;
  allowTrade?: Boolean;
  allowGifts?: Boolean;
  allowMimic?: Boolean;
  allowFollow?: Boolean;
  allowWhisper?: Boolean;
  allowFriendRequests?: Boolean;
  allowBotSpeech?: Boolean;
  allowPetSpeech?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface HabboPreviousValuesPromise
  extends Promise<HabboPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HabboPreviousValuesSubscription
  extends Promise<AsyncIterator<HabboPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  appearOffline: () => Promise<AsyncIterator<Boolean>>;
  allowTrade: () => Promise<AsyncIterator<Boolean>>;
  allowGifts: () => Promise<AsyncIterator<Boolean>>;
  allowMimic: () => Promise<AsyncIterator<Boolean>>;
  allowFollow: () => Promise<AsyncIterator<Boolean>>;
  allowWhisper: () => Promise<AsyncIterator<Boolean>>;
  allowFriendRequests: () => Promise<AsyncIterator<Boolean>>;
  allowBotSpeech: () => Promise<AsyncIterator<Boolean>>;
  allowPetSpeech: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HabboBadgesSubscriptionPayload {
  mutation: MutationType;
  node: HabboBadges;
  updatedFields: String[];
  previousValues: HabboBadgesPreviousValues;
}

export interface HabboBadgesSubscriptionPayloadPromise
  extends Promise<HabboBadgesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HabboBadgesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HabboBadgesPreviousValuesPromise>() => T;
}

export interface HabboBadgesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HabboBadgesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HabboBadgesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HabboBadgesPreviousValuesSubscription>() => T;
}

export interface HabboBadgesPreviousValues {
  id: ID_Output;
  badge: String;
}

export interface HabboBadgesPreviousValuesPromise
  extends Promise<HabboBadgesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  badge: () => Promise<String>;
}

export interface HabboBadgesPreviousValuesSubscription
  extends Promise<AsyncIterator<HabboBadgesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  badge: () => Promise<AsyncIterator<String>>;
}

export interface HabboItemsSubscriptionPayload {
  mutation: MutationType;
  node: HabboItems;
  updatedFields: String[];
  previousValues: HabboItemsPreviousValues;
}

export interface HabboItemsSubscriptionPayloadPromise
  extends Promise<HabboItemsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HabboItemsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HabboItemsPreviousValuesPromise>() => T;
}

export interface HabboItemsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HabboItemsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HabboItemsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HabboItemsPreviousValuesSubscription>() => T;
}

export interface HabboItemsPreviousValues {
  id: ID_Output;
  item?: String;
}

export interface HabboItemsPreviousValuesPromise
  extends Promise<HabboItemsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  item: () => Promise<String>;
}

export interface HabboItemsPreviousValuesSubscription
  extends Promise<AsyncIterator<HabboItemsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  item: () => Promise<AsyncIterator<String>>;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface LanguagePreviousValues {
  id: ID_Output;
  name?: String;
  native?: String;
  code: String;
  enabled?: Boolean;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  native: () => Promise<String>;
  code: () => Promise<String>;
  enabled: () => Promise<Boolean>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  native: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
}

export interface NavigatorCategorySubscriptionPayload {
  mutation: MutationType;
  node: NavigatorCategory;
  updatedFields: String[];
  previousValues: NavigatorCategoryPreviousValues;
}

export interface NavigatorCategorySubscriptionPayloadPromise
  extends Promise<NavigatorCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NavigatorCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NavigatorCategoryPreviousValuesPromise>() => T;
}

export interface NavigatorCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NavigatorCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NavigatorCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NavigatorCategoryPreviousValuesSubscription>() => T;
}

export interface NavigatorCategoryPreviousValues {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorCategoryPreviousValuesPromise
  extends Promise<NavigatorCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface NavigatorCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<NavigatorCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorTabSubscriptionPayload {
  mutation: MutationType;
  node: NavigatorTab;
  updatedFields: String[];
  previousValues: NavigatorTabPreviousValues;
}

export interface NavigatorTabSubscriptionPayloadPromise
  extends Promise<NavigatorTabSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NavigatorTabPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NavigatorTabPreviousValuesPromise>() => T;
}

export interface NavigatorTabSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NavigatorTabSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NavigatorTabSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NavigatorTabPreviousValuesSubscription>() => T;
}

export interface NavigatorTabPreviousValues {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorTabPreviousValuesPromise
  extends Promise<NavigatorTabPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface NavigatorTabPreviousValuesSubscription
  extends Promise<AsyncIterator<NavigatorTabPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface NewsPreviousValues {
  id: ID_Output;
  title?: String;
  summary?: String;
  body?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RankSubscriptionPayload {
  mutation: MutationType;
  node: Rank;
  updatedFields: String[];
  previousValues: RankPreviousValues;
}

export interface RankSubscriptionPayloadPromise
  extends Promise<RankSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RankPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RankPreviousValuesPromise>() => T;
}

export interface RankSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RankSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RankSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RankPreviousValuesSubscription>() => T;
}

export interface RankPreviousValues {
  id: ID_Output;
  order: Int;
  name: String;
}

export interface RankPreviousValuesPromise
  extends Promise<RankPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface RankPreviousValuesSubscription
  extends Promise<AsyncIterator<RankPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  map?: Json;
  floorThickness?: Float;
  wallThickness?: Float;
  wallHeight?: Float;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  currentUsers?: Int;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Float>;
  wallThickness: () => Promise<Float>;
  wallHeight: () => Promise<Float>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Float>>;
  wallThickness: () => Promise<AsyncIterator<Float>>;
  wallHeight: () => Promise<AsyncIterator<Float>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  currentUsers: () => Promise<AsyncIterator<Int>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  password?: String;
  pin?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Json = any;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "banType",
    embedded: false
  },
  {
    name: "banStatus",
    embedded: false
  },
  {
    name: "roomType",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "FurniType",
    embedded: false
  },
  {
    name: "CatalogPageLayout",
    embedded: false
  },
  {
    name: "Ban",
    embedded: false
  },
  {
    name: "Badge",
    embedded: false
  },
  {
    name: "Bot",
    embedded: false
  },
  {
    name: "CatalogFeatured",
    embedded: false
  },
  {
    name: "CatalogPage",
    embedded: false
  },
  {
    name: "CatalogItems",
    embedded: false
  },
  {
    name: "Currencies",
    embedded: false
  },
  {
    name: "Rank",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Chatlog",
    embedded: false
  },
  {
    name: "ChatlogConsole",
    embedded: false
  },
  {
    name: "ChatlogConsoleInvitations",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "NavigatorTab",
    embedded: false
  },
  {
    name: "NavigatorCategory",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  },
  {
    name: "Habbo",
    embedded: false
  },
  {
    name: "HabboBadges",
    embedded: false
  },
  {
    name: "HabboItems",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
